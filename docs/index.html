<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPT Summarizer</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        --surface: #f5f5f5;
        --surface-alt: #ffffff;
        --border: #d0d7de;
        --accent: #2563eb;
        --accent-dark: #1d4ed8;
        --text: #111827;
        --text-muted: #4b5563;
        --shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --surface: #0f172a;
          --surface-alt: #1e293b;
          --border: #334155;
          --accent: #3b82f6;
          --accent-dark: #60a5fa;
          --text: #f8fafc;
          --text-muted: #94a3b8;
          --shadow: 0 12px 32px rgba(2, 6, 23, 0.45);
        }
      }

      body {
        margin: 0;
        background: var(--surface);
        color: var(--text);
      }

      header {
        padding: 2.5rem 1.5rem 1.5rem;
        text-align: center;
      }

      header h1 {
        margin: 0 0 0.75rem;
        font-size: clamp(2rem, 4vw, 2.75rem);
      }

      header p {
        margin: 0;
        max-width: 720px;
        margin-inline: auto;
        line-height: 1.6;
        color: var(--text-muted);
      }

      main {
        max-width: 960px;
        margin: 0 auto 4rem;
        padding: 0 1.5rem 3rem;
      }

      form {
        background: var(--surface-alt);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 2rem;
        box-shadow: var(--shadow);
      }

      .field {
        margin-bottom: 1.75rem;
        display: grid;
        gap: 0.75rem;
      }

      label {
        font-weight: 600;
      }

      textarea {
        min-height: 200px;
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid var(--border);
        resize: vertical;
        background: transparent;
        color: inherit;
        font: inherit;
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button,
      input[type="number"],
      input[type="text"],
      .dynamic-word-limit input {
        font: inherit;
        border-radius: 12px;
        border: 1px solid var(--border);
        padding: 0.65rem 1rem;
        background: transparent;
        color: inherit;
      }

      button {
        background: var(--accent);
        color: #fff;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.15s ease, background 0.2s ease, box-shadow 0.2s ease;
      }

      button.secondary {
        background: transparent;
        color: var(--text);
        border: 1px solid var(--border);
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(37, 99, 235, 0.2);
      }

      button.secondary:hover {
        box-shadow: none;
        border-color: var(--accent);
        color: var(--accent);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .small {
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      .number-inputs {
        display: grid;
        gap: 1rem;
      }

      .dynamic-word-limit {
        display: grid;
        gap: 0.65rem;
      }

      .word-limit-row {
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }

      .word-limit-row span {
        min-width: 4.5rem;
        color: var(--text-muted);
      }

      .status {
        margin-top: 1rem;
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      .results {
        margin-top: 2.5rem;
        display: grid;
        gap: 1.25rem;
      }

      .summary-card {
        border-radius: 18px;
        border: 1px solid var(--border);
        padding: 1.75rem;
        background: var(--surface-alt);
        box-shadow: var(--shadow);
      }

      .summary-card h3 {
        margin: 0 0 0.75rem;
        font-size: 1.15rem;
      }

      .summary-card p {
        margin: 0;
        line-height: 1.6;
      }

      .empty-results {
        padding: 1.5rem;
        border-radius: 16px;
        border: 1px dashed var(--border);
        text-align: center;
        color: var(--text-muted);
      }

      @media (max-width: 640px) {
        form {
          padding: 1.5rem;
        }

        .word-limit-row {
          flex-direction: column;
          align-items: flex-start;
        }

        .word-limit-row span {
          min-width: auto;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>GPT Iterative Summarizer</h1>
      <p>
        Paste a long-form article or document, choose how many summary steps you want,
        and send it to your summarization backend. Each iteration can have its own word
        limit to gradually reveal more detail.
      </p>
    </header>
    <main>
      <form id="summarize-form">
        <div class="field">
          <label for="sourceText">Source text</label>
          <div class="button-row" style="justify-content: flex-end">
            <button id="pasteButton" type="button" class="secondary">Paste</button>
          </div>
          <textarea
            id="sourceText"
            name="sourceText"
            placeholder="Paste or type the text you want to summarize..."
            required
          ></textarea>
        </div>

        <div class="field number-inputs">
          <div>
            <label for="iterations">Iterations</label>
            <input
              id="iterations"
              name="iterations"
              type="number"
              min="1"
              max="8"
              value="3"
              required
            />
            <div class="small">
              Select how many levels of summary you want. The first iteration should be the
              shortest.
            </div>
          </div>

          <div class="dynamic-word-limit" id="wordLimitContainer">
            <!-- Word limit inputs generated by script -->
          </div>
        </div>

        <div class="field">
          <label for="endpoint">Summarization endpoint</label>
          <input
            id="endpoint"
            name="endpoint"
            type="text"
            placeholder="https://your-worker.example.com/summarize"
            autocomplete="url"
          />
          <div class="small">
            Leave blank to use the current origin with <code>/api/summarize</code>.
          </div>
        </div>

        <div class="field">
          <div class="button-row">
            <button id="summarizeButton" type="submit">Summarize</button>
            <button id="resetButton" type="button" class="secondary">Reset</button>
          </div>
          <div id="status" class="status" role="status" aria-live="polite"></div>
        </div>
      </form>

      <section id="results" class="results" aria-live="polite"></section>
    </main>

    <template id="wordLimitTemplate">
      <div class="word-limit-row">
        <span></span>
        <input type="number" min="20" max="1000" />
      </div>
    </template>

    <template id="summaryTemplate">
      <article class="summary-card">
        <h3></h3>
        <p></p>
      </article>
    </template>

    <script>
      const form = document.getElementById("summarize-form");
      const sourceText = document.getElementById("sourceText");
      const iterationsInput = document.getElementById("iterations");
      const pasteButton = document.getElementById("pasteButton");
      const summarizeButton = document.getElementById("summarizeButton");
      const resetButton = document.getElementById("resetButton");
      const statusText = document.getElementById("status");
      const results = document.getElementById("results");
      const endpointInput = document.getElementById("endpoint");
      const wordLimitContainer = document.getElementById("wordLimitContainer");
      const wordLimitTemplate = document.getElementById("wordLimitTemplate");
      const summaryTemplate = document.getElementById("summaryTemplate");

      const DEFAULT_WORD_LIMITS = [80, 160, 320, 480, 640, 800, 900, 1000];
      let pasteInProgress = false;

      function updateWordLimitInputs(iterations) {
        const desiredCount = Math.max(1, Math.min(8, Number(iterations) || 1));
        const currentCount = wordLimitContainer.children.length;

        // Remove extra inputs
        if (currentCount > desiredCount) {
          for (let i = currentCount - 1; i >= desiredCount; i -= 1) {
            wordLimitContainer.removeChild(wordLimitContainer.children[i]);
          }
        }

        // Add missing inputs
        for (let i = currentCount; i < desiredCount; i += 1) {
          const clone = wordLimitTemplate.content.firstElementChild.cloneNode(true);
          const label = clone.querySelector("span");
          const input = clone.querySelector("input");
          label.textContent = `Iteration ${i + 1}`;
          input.name = `wordLimit${i + 1}`;
          input.value = DEFAULT_WORD_LIMITS[i] || DEFAULT_WORD_LIMITS[DEFAULT_WORD_LIMITS.length - 1];
          wordLimitContainer.appendChild(clone);
        }
      }

      async function handlePaste() {
        if (!navigator.clipboard || !navigator.clipboard.readText) {
          statusText.textContent = "Clipboard API is unavailable in this browser.";
          return;
        }

        try {
          const text = await navigator.clipboard.readText();
          if (text) {
            sourceText.value = text;
            sourceText.focus();
            statusText.textContent = "Pasted text from clipboard.";
          } else {
            statusText.textContent = "Clipboard is empty or unavailable.";
          }
        } catch (error) {
          console.error("Clipboard read failed", error);
          statusText.textContent = "Unable to read clipboard contents.";
        }
      }

      async function triggerPaste() {
        if (pasteInProgress) {
          return;
        }

        pasteInProgress = true;
        try {
          await handlePaste();
        } finally {
          pasteInProgress = false;
        }
      }

      function clearResults() {
        results.innerHTML = "";
        const empty = document.createElement("div");
        empty.className = "empty-results";
        empty.textContent = "Summaries will appear here after you submit the form.";
        results.appendChild(empty);
      }

      function renderSummaries(summaries) {
        results.innerHTML = "";

        if (!Array.isArray(summaries) || summaries.length === 0) {
          clearResults();
          return;
        }

        summaries.forEach((summary, index) => {
          const card = summaryTemplate.content.firstElementChild.cloneNode(true);
          const heading = card.querySelector("h3");
          const paragraph = card.querySelector("p");
          const limit = summary.word_limit || summary.wordLimit;
          const iterationNumber = summary.iteration || index + 1;
          heading.textContent = `Iteration ${iterationNumber}` + (limit ? ` · ≤ ${limit} words` : "");
          paragraph.textContent = summary.summary || summary.text || "(Empty summary)";
          results.appendChild(card);
        });
      }

      async function handleSubmit(event) {
        event.preventDefault();
        const iterations = Math.max(1, Math.min(8, Number(iterationsInput.value) || 1));
        const summaryEndpoint = endpointInput.value.trim() || `${window.location.origin}/api/summarize`;

        const wordLimits = Array.from(wordLimitContainer.querySelectorAll("input"))
          .slice(0, iterations)
          .map((input, idx) => ({ iteration: idx + 1, word_limit: Number(input.value) || undefined }));

        const payload = {
          text: sourceText.value.trim(),
          iterations,
          word_limits: wordLimits,
        };

        if (!payload.text) {
          statusText.textContent = "Please enter some text before summarizing.";
          sourceText.focus();
          return;
        }

        summarizeButton.disabled = true;
        summarizeButton.textContent = "Summarizing...";
        statusText.textContent = "Sending request to summarization endpoint...";

        try {
          const response = await fetch(summaryEndpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
          }

          const data = await response.json();
          renderSummaries(data.summaries || []);
          statusText.textContent = "Summaries received.";
        } catch (error) {
          console.error("Summarize failed", error);
          statusText.textContent =
            "Unable to reach the summarization endpoint. Check the URL and your backend logs.";
          clearResults();
        } finally {
          summarizeButton.disabled = false;
          summarizeButton.textContent = "Summarize";
        }
      }

      function handleReset() {
        form.reset();
        statusText.textContent = "";
        updateWordLimitInputs(iterationsInput.value);
        clearResults();
        sourceText.focus();
      }

      // Event listeners
      form.addEventListener("submit", handleSubmit);
      pasteButton.addEventListener("click", triggerPaste);
      resetButton.addEventListener("click", handleReset);
      iterationsInput.addEventListener("change", (event) => {
        updateWordLimitInputs(event.target.value);
      });

      // Initialize UI
      updateWordLimitInputs(iterationsInput.value);
      clearResults();
    </script>
  </body>
</html>
